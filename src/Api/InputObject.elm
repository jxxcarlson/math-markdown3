-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.InputObject exposing (Boolean_comparison_exp, Boolean_comparison_expOptionalFields, Document_aggregate_order_by, Document_aggregate_order_byOptionalFields, Document_append_input, Document_append_inputOptionalFields, Document_arr_rel_insert_input(..), Document_arr_rel_insert_inputOptionalFields, Document_arr_rel_insert_inputRaw, Document_arr_rel_insert_inputRequiredFields, Document_bool_exp(..), Document_bool_expOptionalFields, Document_bool_expRaw, Document_delete_at_path_input, Document_delete_at_path_inputOptionalFields, Document_delete_elem_input, Document_delete_elem_inputOptionalFields, Document_delete_key_input, Document_delete_key_inputOptionalFields, Document_insert_input(..), Document_insert_inputOptionalFields, Document_insert_inputRaw, Document_max_order_by, Document_max_order_byOptionalFields, Document_min_order_by, Document_min_order_byOptionalFields, Document_obj_rel_insert_input(..), Document_obj_rel_insert_inputOptionalFields, Document_obj_rel_insert_inputRaw, Document_obj_rel_insert_inputRequiredFields, Document_on_conflict, Document_on_conflictRequiredFields, Document_order_by(..), Document_order_byOptionalFields, Document_order_byRaw, Document_prepend_input, Document_prepend_inputOptionalFields, Document_set_input, Document_set_inputOptionalFields, Jsonb_comparison_exp, Jsonb_comparison_expOptionalFields, String_comparison_exp, String_comparison_expOptionalFields, Timestamptz_comparison_exp, Timestamptz_comparison_expOptionalFields, User_aggregate_order_by, User_aggregate_order_byOptionalFields, User_arr_rel_insert_input(..), User_arr_rel_insert_inputOptionalFields, User_arr_rel_insert_inputRaw, User_arr_rel_insert_inputRequiredFields, User_bool_exp(..), User_bool_expOptionalFields, User_bool_expRaw, User_insert_input(..), User_insert_inputOptionalFields, User_insert_inputRaw, User_max_order_by, User_max_order_byOptionalFields, User_min_order_by, User_min_order_byOptionalFields, User_obj_rel_insert_input(..), User_obj_rel_insert_inputOptionalFields, User_obj_rel_insert_inputRaw, User_obj_rel_insert_inputRequiredFields, User_on_conflict, User_on_conflictRequiredFields, User_order_by, User_order_byOptionalFields, User_set_input, User_set_inputOptionalFields, Uuid_comparison_exp, Uuid_comparison_expOptionalFields, buildBoolean_comparison_exp, buildDocument_aggregate_order_by, buildDocument_append_input, buildDocument_arr_rel_insert_input, buildDocument_bool_exp, buildDocument_delete_at_path_input, buildDocument_delete_elem_input, buildDocument_delete_key_input, buildDocument_insert_input, buildDocument_max_order_by, buildDocument_min_order_by, buildDocument_obj_rel_insert_input, buildDocument_on_conflict, buildDocument_order_by, buildDocument_prepend_input, buildDocument_set_input, buildJsonb_comparison_exp, buildString_comparison_exp, buildTimestamptz_comparison_exp, buildUser_aggregate_order_by, buildUser_arr_rel_insert_input, buildUser_bool_exp, buildUser_insert_input, buildUser_max_order_by, buildUser_min_order_by, buildUser_obj_rel_insert_input, buildUser_on_conflict, buildUser_order_by, buildUser_set_input, buildUuid_comparison_exp, encodeBoolean_comparison_exp, encodeDocument_aggregate_order_by, encodeDocument_append_input, encodeDocument_arr_rel_insert_input, encodeDocument_bool_exp, encodeDocument_delete_at_path_input, encodeDocument_delete_elem_input, encodeDocument_delete_key_input, encodeDocument_insert_input, encodeDocument_max_order_by, encodeDocument_min_order_by, encodeDocument_obj_rel_insert_input, encodeDocument_on_conflict, encodeDocument_order_by, encodeDocument_prepend_input, encodeDocument_set_input, encodeJsonb_comparison_exp, encodeString_comparison_exp, encodeTimestamptz_comparison_exp, encodeUser_aggregate_order_by, encodeUser_arr_rel_insert_input, encodeUser_bool_exp, encodeUser_insert_input, encodeUser_max_order_by, encodeUser_min_order_by, encodeUser_obj_rel_insert_input, encodeUser_on_conflict, encodeUser_order_by, encodeUser_set_input, encodeUuid_comparison_exp)

import Api.Enum.Document_constraint
import Api.Enum.Document_update_column
import Api.Enum.Order_by
import Api.Enum.User_constraint
import Api.Enum.User_update_column
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import CustomScalarCodecs
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildBoolean_comparison_exp : (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields) -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input.eq_ ), ( "_gt", Encode.bool |> Encode.optional input.gt_ ), ( "_gte", Encode.bool |> Encode.optional input.gte_ ), ( "_in", (Encode.bool |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input.lt_ ), ( "_lte", Encode.bool |> Encode.optional input.lte_ ), ( "_neq", Encode.bool |> Encode.optional input.neq_ ), ( "_nin", (Encode.bool |> Encode.list) |> Encode.optional input.nin_ ) ]


buildDocument_aggregate_order_by : (Document_aggregate_order_byOptionalFields -> Document_aggregate_order_byOptionalFields) -> Document_aggregate_order_by
buildDocument_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias Document_aggregate_order_byOptionalFields =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Document_max_order_by
    , min : OptionalArgument Document_min_order_by
    }


{-| Type for the Document\_aggregate\_order\_by input object.
-}
type alias Document_aggregate_order_by =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Document_max_order_by
    , min : OptionalArgument Document_min_order_by
    }


{-| Encode a Document\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeDocument_aggregate_order_by : Document_aggregate_order_by -> Value
encodeDocument_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeDocument_max_order_by |> Encode.optional input.max ), ( "min", encodeDocument_min_order_by |> Encode.optional input.min ) ]


buildDocument_append_input : (Document_append_inputOptionalFields -> Document_append_inputOptionalFields) -> Document_append_input
buildDocument_append_input fillOptionals =
    let
        optionals =
            fillOptionals
                { tags = Absent }
    in
    { tags = optionals.tags }


type alias Document_append_inputOptionalFields =
    { tags : OptionalArgument CustomScalarCodecs.Jsonb }


{-| Type for the Document\_append\_input input object.
-}
type alias Document_append_input =
    { tags : OptionalArgument CustomScalarCodecs.Jsonb }


{-| Encode a Document\_append\_input into a value that can be used as an argument.
-}
encodeDocument_append_input : Document_append_input -> Value
encodeDocument_append_input input =
    Encode.maybeObject
        [ ( "tags", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.tags ) ]


buildDocument_arr_rel_insert_input : Document_arr_rel_insert_inputRequiredFields -> (Document_arr_rel_insert_inputOptionalFields -> Document_arr_rel_insert_inputOptionalFields) -> Document_arr_rel_insert_input
buildDocument_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Document_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Document_arr_rel_insert_inputRequiredFields =
    { data : List Document_insert_input }


type alias Document_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Document_on_conflict }


{-| Type alias for the `Document_arr_rel_insert_input` attributes. Note that this type
needs to use the `Document_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Document_arr_rel_insert_inputRaw =
    { data : List Document_insert_input
    , on_conflict : OptionalArgument Document_on_conflict
    }


{-| Type for the Document\_arr\_rel\_insert\_input input object.
-}
type Document_arr_rel_insert_input
    = Document_arr_rel_insert_input Document_arr_rel_insert_inputRaw


{-| Encode a Document\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeDocument_arr_rel_insert_input : Document_arr_rel_insert_input -> Value
encodeDocument_arr_rel_insert_input (Document_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeDocument_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeDocument_on_conflict |> Encode.optional input.on_conflict ) ]


buildDocument_bool_exp : (Document_bool_expOptionalFields -> Document_bool_expOptionalFields) -> Document_bool_exp
buildDocument_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, authorIdentifier = Absent, content = Absent, id = Absent, identifier = Absent, public = Absent, tags = Absent, timeStamp = Absent, title = Absent, user = Absent }
    in
    Document_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, authorIdentifier = optionals.authorIdentifier, content = optionals.content, id = optionals.id, identifier = optionals.identifier, public = optionals.public, tags = optionals.tags, timeStamp = optionals.timeStamp, title = optionals.title, user = optionals.user }


type alias Document_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Document_bool_exp))
    , not_ : OptionalArgument Document_bool_exp
    , or_ : OptionalArgument (List (Maybe Document_bool_exp))
    , authorIdentifier : OptionalArgument String_comparison_exp
    , content : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , identifier : OptionalArgument String_comparison_exp
    , public : OptionalArgument Boolean_comparison_exp
    , tags : OptionalArgument Jsonb_comparison_exp
    , timeStamp : OptionalArgument Timestamptz_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , user : OptionalArgument User_bool_exp
    }


{-| Type alias for the `Document_bool_exp` attributes. Note that this type
needs to use the `Document_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Document_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Document_bool_exp))
    , not_ : OptionalArgument Document_bool_exp
    , or_ : OptionalArgument (List (Maybe Document_bool_exp))
    , authorIdentifier : OptionalArgument String_comparison_exp
    , content : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , identifier : OptionalArgument String_comparison_exp
    , public : OptionalArgument Boolean_comparison_exp
    , tags : OptionalArgument Jsonb_comparison_exp
    , timeStamp : OptionalArgument Timestamptz_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , user : OptionalArgument User_bool_exp
    }


{-| Type for the Document\_bool\_exp input object.
-}
type Document_bool_exp
    = Document_bool_exp Document_bool_expRaw


{-| Encode a Document\_bool\_exp into a value that can be used as an argument.
-}
encodeDocument_bool_exp : Document_bool_exp -> Value
encodeDocument_bool_exp (Document_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeDocument_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeDocument_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeDocument_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "authorIdentifier", encodeString_comparison_exp |> Encode.optional input.authorIdentifier ), ( "content", encodeString_comparison_exp |> Encode.optional input.content ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "identifier", encodeString_comparison_exp |> Encode.optional input.identifier ), ( "public", encodeBoolean_comparison_exp |> Encode.optional input.public ), ( "tags", encodeJsonb_comparison_exp |> Encode.optional input.tags ), ( "timeStamp", encodeTimestamptz_comparison_exp |> Encode.optional input.timeStamp ), ( "title", encodeString_comparison_exp |> Encode.optional input.title ), ( "user", encodeUser_bool_exp |> Encode.optional input.user ) ]


buildDocument_delete_at_path_input : (Document_delete_at_path_inputOptionalFields -> Document_delete_at_path_inputOptionalFields) -> Document_delete_at_path_input
buildDocument_delete_at_path_input fillOptionals =
    let
        optionals =
            fillOptionals
                { tags = Absent }
    in
    { tags = optionals.tags }


type alias Document_delete_at_path_inputOptionalFields =
    { tags : OptionalArgument (List (Maybe String)) }


{-| Type for the Document\_delete\_at\_path\_input input object.
-}
type alias Document_delete_at_path_input =
    { tags : OptionalArgument (List (Maybe String)) }


{-| Encode a Document\_delete\_at\_path\_input into a value that can be used as an argument.
-}
encodeDocument_delete_at_path_input : Document_delete_at_path_input -> Value
encodeDocument_delete_at_path_input input =
    Encode.maybeObject
        [ ( "tags", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.tags ) ]


buildDocument_delete_elem_input : (Document_delete_elem_inputOptionalFields -> Document_delete_elem_inputOptionalFields) -> Document_delete_elem_input
buildDocument_delete_elem_input fillOptionals =
    let
        optionals =
            fillOptionals
                { tags = Absent }
    in
    { tags = optionals.tags }


type alias Document_delete_elem_inputOptionalFields =
    { tags : OptionalArgument Int }


{-| Type for the Document\_delete\_elem\_input input object.
-}
type alias Document_delete_elem_input =
    { tags : OptionalArgument Int }


{-| Encode a Document\_delete\_elem\_input into a value that can be used as an argument.
-}
encodeDocument_delete_elem_input : Document_delete_elem_input -> Value
encodeDocument_delete_elem_input input =
    Encode.maybeObject
        [ ( "tags", Encode.int |> Encode.optional input.tags ) ]


buildDocument_delete_key_input : (Document_delete_key_inputOptionalFields -> Document_delete_key_inputOptionalFields) -> Document_delete_key_input
buildDocument_delete_key_input fillOptionals =
    let
        optionals =
            fillOptionals
                { tags = Absent }
    in
    { tags = optionals.tags }


type alias Document_delete_key_inputOptionalFields =
    { tags : OptionalArgument String }


{-| Type for the Document\_delete\_key\_input input object.
-}
type alias Document_delete_key_input =
    { tags : OptionalArgument String }


{-| Encode a Document\_delete\_key\_input into a value that can be used as an argument.
-}
encodeDocument_delete_key_input : Document_delete_key_input -> Value
encodeDocument_delete_key_input input =
    Encode.maybeObject
        [ ( "tags", Encode.string |> Encode.optional input.tags ) ]


buildDocument_insert_input : (Document_insert_inputOptionalFields -> Document_insert_inputOptionalFields) -> Document_insert_input
buildDocument_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { authorIdentifier = Absent, content = Absent, id = Absent, identifier = Absent, public = Absent, tags = Absent, timeStamp = Absent, title = Absent, user = Absent }
    in
    Document_insert_input { authorIdentifier = optionals.authorIdentifier, content = optionals.content, id = optionals.id, identifier = optionals.identifier, public = optionals.public, tags = optionals.tags, timeStamp = optionals.timeStamp, title = optionals.title, user = optionals.user }


type alias Document_insert_inputOptionalFields =
    { authorIdentifier : OptionalArgument String
    , content : OptionalArgument String
    , id : OptionalArgument CustomScalarCodecs.Uuid
    , identifier : OptionalArgument String
    , public : OptionalArgument Bool
    , tags : OptionalArgument CustomScalarCodecs.Jsonb
    , timeStamp : OptionalArgument CustomScalarCodecs.Timestamptz
    , title : OptionalArgument String
    , user : OptionalArgument User_obj_rel_insert_input
    }


{-| Type alias for the `Document_insert_input` attributes. Note that this type
needs to use the `Document_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Document_insert_inputRaw =
    { authorIdentifier : OptionalArgument String
    , content : OptionalArgument String
    , id : OptionalArgument CustomScalarCodecs.Uuid
    , identifier : OptionalArgument String
    , public : OptionalArgument Bool
    , tags : OptionalArgument CustomScalarCodecs.Jsonb
    , timeStamp : OptionalArgument CustomScalarCodecs.Timestamptz
    , title : OptionalArgument String
    , user : OptionalArgument User_obj_rel_insert_input
    }


{-| Type for the Document\_insert\_input input object.
-}
type Document_insert_input
    = Document_insert_input Document_insert_inputRaw


{-| Encode a Document\_insert\_input into a value that can be used as an argument.
-}
encodeDocument_insert_input : Document_insert_input -> Value
encodeDocument_insert_input (Document_insert_input input) =
    Encode.maybeObject
        [ ( "authorIdentifier", Encode.string |> Encode.optional input.authorIdentifier ), ( "content", Encode.string |> Encode.optional input.content ), ( "id", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "identifier", Encode.string |> Encode.optional input.identifier ), ( "public", Encode.bool |> Encode.optional input.public ), ( "tags", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.tags ), ( "timeStamp", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.timeStamp ), ( "title", Encode.string |> Encode.optional input.title ), ( "user", encodeUser_obj_rel_insert_input |> Encode.optional input.user ) ]


buildDocument_max_order_by : (Document_max_order_byOptionalFields -> Document_max_order_byOptionalFields) -> Document_max_order_by
buildDocument_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { authorIdentifier = Absent, content = Absent, identifier = Absent, timeStamp = Absent, title = Absent }
    in
    { authorIdentifier = optionals.authorIdentifier, content = optionals.content, identifier = optionals.identifier, timeStamp = optionals.timeStamp, title = optionals.title }


type alias Document_max_order_byOptionalFields =
    { authorIdentifier : OptionalArgument Api.Enum.Order_by.Order_by
    , content : OptionalArgument Api.Enum.Order_by.Order_by
    , identifier : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , title : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Document\_max\_order\_by input object.
-}
type alias Document_max_order_by =
    { authorIdentifier : OptionalArgument Api.Enum.Order_by.Order_by
    , content : OptionalArgument Api.Enum.Order_by.Order_by
    , identifier : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , title : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Document\_max\_order\_by into a value that can be used as an argument.
-}
encodeDocument_max_order_by : Document_max_order_by -> Value
encodeDocument_max_order_by input =
    Encode.maybeObject
        [ ( "authorIdentifier", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.authorIdentifier ), ( "content", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.content ), ( "identifier", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.identifier ), ( "timeStamp", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.timeStamp ), ( "title", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.title ) ]


buildDocument_min_order_by : (Document_min_order_byOptionalFields -> Document_min_order_byOptionalFields) -> Document_min_order_by
buildDocument_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { authorIdentifier = Absent, content = Absent, identifier = Absent, timeStamp = Absent, title = Absent }
    in
    { authorIdentifier = optionals.authorIdentifier, content = optionals.content, identifier = optionals.identifier, timeStamp = optionals.timeStamp, title = optionals.title }


type alias Document_min_order_byOptionalFields =
    { authorIdentifier : OptionalArgument Api.Enum.Order_by.Order_by
    , content : OptionalArgument Api.Enum.Order_by.Order_by
    , identifier : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , title : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Document\_min\_order\_by input object.
-}
type alias Document_min_order_by =
    { authorIdentifier : OptionalArgument Api.Enum.Order_by.Order_by
    , content : OptionalArgument Api.Enum.Order_by.Order_by
    , identifier : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , title : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Document\_min\_order\_by into a value that can be used as an argument.
-}
encodeDocument_min_order_by : Document_min_order_by -> Value
encodeDocument_min_order_by input =
    Encode.maybeObject
        [ ( "authorIdentifier", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.authorIdentifier ), ( "content", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.content ), ( "identifier", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.identifier ), ( "timeStamp", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.timeStamp ), ( "title", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.title ) ]


buildDocument_obj_rel_insert_input : Document_obj_rel_insert_inputRequiredFields -> (Document_obj_rel_insert_inputOptionalFields -> Document_obj_rel_insert_inputOptionalFields) -> Document_obj_rel_insert_input
buildDocument_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Document_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Document_obj_rel_insert_inputRequiredFields =
    { data : Document_insert_input }


type alias Document_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Document_on_conflict }


{-| Type alias for the `Document_obj_rel_insert_input` attributes. Note that this type
needs to use the `Document_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Document_obj_rel_insert_inputRaw =
    { data : Document_insert_input
    , on_conflict : OptionalArgument Document_on_conflict
    }


{-| Type for the Document\_obj\_rel\_insert\_input input object.
-}
type Document_obj_rel_insert_input
    = Document_obj_rel_insert_input Document_obj_rel_insert_inputRaw


{-| Encode a Document\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeDocument_obj_rel_insert_input : Document_obj_rel_insert_input -> Value
encodeDocument_obj_rel_insert_input (Document_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeDocument_insert_input input.data |> Just ), ( "on_conflict", encodeDocument_on_conflict |> Encode.optional input.on_conflict ) ]


buildDocument_on_conflict : Document_on_conflictRequiredFields -> Document_on_conflict
buildDocument_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias Document_on_conflictRequiredFields =
    { constraint : Api.Enum.Document_constraint.Document_constraint
    , update_columns : List Api.Enum.Document_update_column.Document_update_column
    }


{-| Type for the Document\_on\_conflict input object.
-}
type alias Document_on_conflict =
    { constraint : Api.Enum.Document_constraint.Document_constraint
    , update_columns : List Api.Enum.Document_update_column.Document_update_column
    }


{-| Encode a Document\_on\_conflict into a value that can be used as an argument.
-}
encodeDocument_on_conflict : Document_on_conflict -> Value
encodeDocument_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Document_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Document_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildDocument_order_by : (Document_order_byOptionalFields -> Document_order_byOptionalFields) -> Document_order_by
buildDocument_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { authorIdentifier = Absent, content = Absent, id = Absent, identifier = Absent, public = Absent, tags = Absent, timeStamp = Absent, title = Absent, user = Absent }
    in
    Document_order_by { authorIdentifier = optionals.authorIdentifier, content = optionals.content, id = optionals.id, identifier = optionals.identifier, public = optionals.public, tags = optionals.tags, timeStamp = optionals.timeStamp, title = optionals.title, user = optionals.user }


type alias Document_order_byOptionalFields =
    { authorIdentifier : OptionalArgument Api.Enum.Order_by.Order_by
    , content : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , identifier : OptionalArgument Api.Enum.Order_by.Order_by
    , public : OptionalArgument Api.Enum.Order_by.Order_by
    , tags : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , title : OptionalArgument Api.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    }


{-| Type alias for the `Document_order_by` attributes. Note that this type
needs to use the `Document_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Document_order_byRaw =
    { authorIdentifier : OptionalArgument Api.Enum.Order_by.Order_by
    , content : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , identifier : OptionalArgument Api.Enum.Order_by.Order_by
    , public : OptionalArgument Api.Enum.Order_by.Order_by
    , tags : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , title : OptionalArgument Api.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    }


{-| Type for the Document\_order\_by input object.
-}
type Document_order_by
    = Document_order_by Document_order_byRaw


{-| Encode a Document\_order\_by into a value that can be used as an argument.
-}
encodeDocument_order_by : Document_order_by -> Value
encodeDocument_order_by (Document_order_by input) =
    Encode.maybeObject
        [ ( "authorIdentifier", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.authorIdentifier ), ( "content", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.content ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "identifier", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.identifier ), ( "public", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.public ), ( "tags", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.tags ), ( "timeStamp", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.timeStamp ), ( "title", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.title ), ( "user", encodeUser_order_by |> Encode.optional input.user ) ]


buildDocument_prepend_input : (Document_prepend_inputOptionalFields -> Document_prepend_inputOptionalFields) -> Document_prepend_input
buildDocument_prepend_input fillOptionals =
    let
        optionals =
            fillOptionals
                { tags = Absent }
    in
    { tags = optionals.tags }


type alias Document_prepend_inputOptionalFields =
    { tags : OptionalArgument CustomScalarCodecs.Jsonb }


{-| Type for the Document\_prepend\_input input object.
-}
type alias Document_prepend_input =
    { tags : OptionalArgument CustomScalarCodecs.Jsonb }


{-| Encode a Document\_prepend\_input into a value that can be used as an argument.
-}
encodeDocument_prepend_input : Document_prepend_input -> Value
encodeDocument_prepend_input input =
    Encode.maybeObject
        [ ( "tags", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.tags ) ]


buildDocument_set_input : (Document_set_inputOptionalFields -> Document_set_inputOptionalFields) -> Document_set_input
buildDocument_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { authorIdentifier = Absent, content = Absent, id = Absent, identifier = Absent, public = Absent, tags = Absent, timeStamp = Absent, title = Absent }
    in
    { authorIdentifier = optionals.authorIdentifier, content = optionals.content, id = optionals.id, identifier = optionals.identifier, public = optionals.public, tags = optionals.tags, timeStamp = optionals.timeStamp, title = optionals.title }


type alias Document_set_inputOptionalFields =
    { authorIdentifier : OptionalArgument String
    , content : OptionalArgument String
    , id : OptionalArgument CustomScalarCodecs.Uuid
    , identifier : OptionalArgument String
    , public : OptionalArgument Bool
    , tags : OptionalArgument CustomScalarCodecs.Jsonb
    , timeStamp : OptionalArgument CustomScalarCodecs.Timestamptz
    , title : OptionalArgument String
    }


{-| Type for the Document\_set\_input input object.
-}
type alias Document_set_input =
    { authorIdentifier : OptionalArgument String
    , content : OptionalArgument String
    , id : OptionalArgument CustomScalarCodecs.Uuid
    , identifier : OptionalArgument String
    , public : OptionalArgument Bool
    , tags : OptionalArgument CustomScalarCodecs.Jsonb
    , timeStamp : OptionalArgument CustomScalarCodecs.Timestamptz
    , title : OptionalArgument String
    }


{-| Encode a Document\_set\_input into a value that can be used as an argument.
-}
encodeDocument_set_input : Document_set_input -> Value
encodeDocument_set_input input =
    Encode.maybeObject
        [ ( "authorIdentifier", Encode.string |> Encode.optional input.authorIdentifier ), ( "content", Encode.string |> Encode.optional input.content ), ( "id", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "identifier", Encode.string |> Encode.optional input.identifier ), ( "public", Encode.bool |> Encode.optional input.public ), ( "tags", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.tags ), ( "timeStamp", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.timeStamp ), ( "title", Encode.string |> Encode.optional input.title ) ]


buildJsonb_comparison_exp : (Jsonb_comparison_expOptionalFields -> Jsonb_comparison_expOptionalFields) -> Jsonb_comparison_exp
buildJsonb_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { contained_in_ = Absent, contains_ = Absent, eq_ = Absent, gt_ = Absent, gte_ = Absent, has_key_ = Absent, has_keys_all_ = Absent, has_keys_any_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { contained_in_ = optionals.contained_in_, contains_ = optionals.contains_, eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, has_key_ = optionals.has_key_, has_keys_all_ = optionals.has_keys_all_, has_keys_any_ = optionals.has_keys_any_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Jsonb_comparison_expOptionalFields =
    { contained_in_ : OptionalArgument CustomScalarCodecs.Jsonb
    , contains_ : OptionalArgument CustomScalarCodecs.Jsonb
    , eq_ : OptionalArgument CustomScalarCodecs.Jsonb
    , gt_ : OptionalArgument CustomScalarCodecs.Jsonb
    , gte_ : OptionalArgument CustomScalarCodecs.Jsonb
    , has_key_ : OptionalArgument String
    , has_keys_all_ : OptionalArgument (List String)
    , has_keys_any_ : OptionalArgument (List String)
    , in_ : OptionalArgument (List CustomScalarCodecs.Jsonb)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Jsonb
    , lte_ : OptionalArgument CustomScalarCodecs.Jsonb
    , neq_ : OptionalArgument CustomScalarCodecs.Jsonb
    , nin_ : OptionalArgument (List CustomScalarCodecs.Jsonb)
    }


{-| Type for the Jsonb\_comparison\_exp input object.
-}
type alias Jsonb_comparison_exp =
    { contained_in_ : OptionalArgument CustomScalarCodecs.Jsonb
    , contains_ : OptionalArgument CustomScalarCodecs.Jsonb
    , eq_ : OptionalArgument CustomScalarCodecs.Jsonb
    , gt_ : OptionalArgument CustomScalarCodecs.Jsonb
    , gte_ : OptionalArgument CustomScalarCodecs.Jsonb
    , has_key_ : OptionalArgument String
    , has_keys_all_ : OptionalArgument (List String)
    , has_keys_any_ : OptionalArgument (List String)
    , in_ : OptionalArgument (List CustomScalarCodecs.Jsonb)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Jsonb
    , lte_ : OptionalArgument CustomScalarCodecs.Jsonb
    , neq_ : OptionalArgument CustomScalarCodecs.Jsonb
    , nin_ : OptionalArgument (List CustomScalarCodecs.Jsonb)
    }


{-| Encode a Jsonb\_comparison\_exp into a value that can be used as an argument.
-}
encodeJsonb_comparison_exp : Jsonb_comparison_exp -> Value
encodeJsonb_comparison_exp input =
    Encode.maybeObject
        [ ( "_contained_in", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.contained_in_ ), ( "_contains", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.contains_ ), ( "_eq", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.gte_ ), ( "_has_key", Encode.string |> Encode.optional input.has_key_ ), ( "_has_keys_all", (Encode.string |> Encode.list) |> Encode.optional input.has_keys_all_ ), ( "_has_keys_any", (Encode.string |> Encode.list) |> Encode.optional input.has_keys_any_ ), ( "_in", ((CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecJsonb) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , gt_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , gte_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List CustomScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , lte_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , neq_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List CustomScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , gt_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , gte_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List CustomScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , lte_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , neq_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List CustomScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildUser_aggregate_order_by : (User_aggregate_order_byOptionalFields -> User_aggregate_order_byOptionalFields) -> User_aggregate_order_by
buildUser_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias User_aggregate_order_byOptionalFields =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument User_max_order_by
    , min : OptionalArgument User_min_order_by
    }


{-| Type for the User\_aggregate\_order\_by input object.
-}
type alias User_aggregate_order_by =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument User_max_order_by
    , min : OptionalArgument User_min_order_by
    }


{-| Encode a User\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeUser_aggregate_order_by : User_aggregate_order_by -> Value
encodeUser_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeUser_max_order_by |> Encode.optional input.max ), ( "min", encodeUser_min_order_by |> Encode.optional input.min ) ]


buildUser_arr_rel_insert_input : User_arr_rel_insert_inputRequiredFields -> (User_arr_rel_insert_inputOptionalFields -> User_arr_rel_insert_inputOptionalFields) -> User_arr_rel_insert_input
buildUser_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    User_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias User_arr_rel_insert_inputRequiredFields =
    { data : List User_insert_input }


type alias User_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument User_on_conflict }


{-| Type alias for the `User_arr_rel_insert_input` attributes. Note that this type
needs to use the `User_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_arr_rel_insert_inputRaw =
    { data : List User_insert_input
    , on_conflict : OptionalArgument User_on_conflict
    }


{-| Type for the User\_arr\_rel\_insert\_input input object.
-}
type User_arr_rel_insert_input
    = User_arr_rel_insert_input User_arr_rel_insert_inputRaw


{-| Encode a User\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUser_arr_rel_insert_input : User_arr_rel_insert_input -> Value
encodeUser_arr_rel_insert_input (User_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeUser_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeUser_on_conflict |> Encode.optional input.on_conflict ) ]


buildUser_bool_exp : (User_bool_expOptionalFields -> User_bool_expOptionalFields) -> User_bool_exp
buildUser_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, admin = Absent, documents = Absent, email = Absent, firstName = Absent, id = Absent, lastName = Absent, timeStamp = Absent, username = Absent }
    in
    User_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, admin = optionals.admin, documents = optionals.documents, email = optionals.email, firstName = optionals.firstName, id = optionals.id, lastName = optionals.lastName, timeStamp = optionals.timeStamp, username = optionals.username }


type alias User_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe User_bool_exp))
    , not_ : OptionalArgument User_bool_exp
    , or_ : OptionalArgument (List (Maybe User_bool_exp))
    , admin : OptionalArgument Boolean_comparison_exp
    , documents : OptionalArgument Document_bool_exp
    , email : OptionalArgument String_comparison_exp
    , firstName : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastName : OptionalArgument String_comparison_exp
    , timeStamp : OptionalArgument Timestamptz_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `User_bool_exp` attributes. Note that this type
needs to use the `User_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe User_bool_exp))
    , not_ : OptionalArgument User_bool_exp
    , or_ : OptionalArgument (List (Maybe User_bool_exp))
    , admin : OptionalArgument Boolean_comparison_exp
    , documents : OptionalArgument Document_bool_exp
    , email : OptionalArgument String_comparison_exp
    , firstName : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastName : OptionalArgument String_comparison_exp
    , timeStamp : OptionalArgument Timestamptz_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type for the User\_bool\_exp input object.
-}
type User_bool_exp
    = User_bool_exp User_bool_expRaw


{-| Encode a User\_bool\_exp into a value that can be used as an argument.
-}
encodeUser_bool_exp : User_bool_exp -> Value
encodeUser_bool_exp (User_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeUser_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeUser_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeUser_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "admin", encodeBoolean_comparison_exp |> Encode.optional input.admin ), ( "documents", encodeDocument_bool_exp |> Encode.optional input.documents ), ( "email", encodeString_comparison_exp |> Encode.optional input.email ), ( "firstName", encodeString_comparison_exp |> Encode.optional input.firstName ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "lastName", encodeString_comparison_exp |> Encode.optional input.lastName ), ( "timeStamp", encodeTimestamptz_comparison_exp |> Encode.optional input.timeStamp ), ( "username", encodeString_comparison_exp |> Encode.optional input.username ) ]


buildUser_insert_input : (User_insert_inputOptionalFields -> User_insert_inputOptionalFields) -> User_insert_input
buildUser_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { admin = Absent, documents = Absent, email = Absent, firstName = Absent, id = Absent, lastName = Absent, timeStamp = Absent, username = Absent }
    in
    User_insert_input { admin = optionals.admin, documents = optionals.documents, email = optionals.email, firstName = optionals.firstName, id = optionals.id, lastName = optionals.lastName, timeStamp = optionals.timeStamp, username = optionals.username }


type alias User_insert_inputOptionalFields =
    { admin : OptionalArgument Bool
    , documents : OptionalArgument Document_arr_rel_insert_input
    , email : OptionalArgument String
    , firstName : OptionalArgument String
    , id : OptionalArgument CustomScalarCodecs.Uuid
    , lastName : OptionalArgument String
    , timeStamp : OptionalArgument CustomScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type alias for the `User_insert_input` attributes. Note that this type
needs to use the `User_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_insert_inputRaw =
    { admin : OptionalArgument Bool
    , documents : OptionalArgument Document_arr_rel_insert_input
    , email : OptionalArgument String
    , firstName : OptionalArgument String
    , id : OptionalArgument CustomScalarCodecs.Uuid
    , lastName : OptionalArgument String
    , timeStamp : OptionalArgument CustomScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type for the User\_insert\_input input object.
-}
type User_insert_input
    = User_insert_input User_insert_inputRaw


{-| Encode a User\_insert\_input into a value that can be used as an argument.
-}
encodeUser_insert_input : User_insert_input -> Value
encodeUser_insert_input (User_insert_input input) =
    Encode.maybeObject
        [ ( "admin", Encode.bool |> Encode.optional input.admin ), ( "documents", encodeDocument_arr_rel_insert_input |> Encode.optional input.documents ), ( "email", Encode.string |> Encode.optional input.email ), ( "firstName", Encode.string |> Encode.optional input.firstName ), ( "id", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "lastName", Encode.string |> Encode.optional input.lastName ), ( "timeStamp", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.timeStamp ), ( "username", Encode.string |> Encode.optional input.username ) ]


buildUser_max_order_by : (User_max_order_byOptionalFields -> User_max_order_byOptionalFields) -> User_max_order_by
buildUser_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { email = Absent, firstName = Absent, lastName = Absent, timeStamp = Absent, username = Absent }
    in
    { email = optionals.email, firstName = optionals.firstName, lastName = optionals.lastName, timeStamp = optionals.timeStamp, username = optionals.username }


type alias User_max_order_byOptionalFields =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , firstName : OptionalArgument Api.Enum.Order_by.Order_by
    , lastName : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , username : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the User\_max\_order\_by input object.
-}
type alias User_max_order_by =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , firstName : OptionalArgument Api.Enum.Order_by.Order_by
    , lastName : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , username : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a User\_max\_order\_by into a value that can be used as an argument.
-}
encodeUser_max_order_by : User_max_order_by -> Value
encodeUser_max_order_by input =
    Encode.maybeObject
        [ ( "email", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.email ), ( "firstName", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.firstName ), ( "lastName", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.lastName ), ( "timeStamp", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.timeStamp ), ( "username", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUser_min_order_by : (User_min_order_byOptionalFields -> User_min_order_byOptionalFields) -> User_min_order_by
buildUser_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { email = Absent, firstName = Absent, lastName = Absent, timeStamp = Absent, username = Absent }
    in
    { email = optionals.email, firstName = optionals.firstName, lastName = optionals.lastName, timeStamp = optionals.timeStamp, username = optionals.username }


type alias User_min_order_byOptionalFields =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , firstName : OptionalArgument Api.Enum.Order_by.Order_by
    , lastName : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , username : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the User\_min\_order\_by input object.
-}
type alias User_min_order_by =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , firstName : OptionalArgument Api.Enum.Order_by.Order_by
    , lastName : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , username : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a User\_min\_order\_by into a value that can be used as an argument.
-}
encodeUser_min_order_by : User_min_order_by -> Value
encodeUser_min_order_by input =
    Encode.maybeObject
        [ ( "email", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.email ), ( "firstName", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.firstName ), ( "lastName", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.lastName ), ( "timeStamp", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.timeStamp ), ( "username", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUser_obj_rel_insert_input : User_obj_rel_insert_inputRequiredFields -> (User_obj_rel_insert_inputOptionalFields -> User_obj_rel_insert_inputOptionalFields) -> User_obj_rel_insert_input
buildUser_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    User_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias User_obj_rel_insert_inputRequiredFields =
    { data : User_insert_input }


type alias User_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument User_on_conflict }


{-| Type alias for the `User_obj_rel_insert_input` attributes. Note that this type
needs to use the `User_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_obj_rel_insert_inputRaw =
    { data : User_insert_input
    , on_conflict : OptionalArgument User_on_conflict
    }


{-| Type for the User\_obj\_rel\_insert\_input input object.
-}
type User_obj_rel_insert_input
    = User_obj_rel_insert_input User_obj_rel_insert_inputRaw


{-| Encode a User\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUser_obj_rel_insert_input : User_obj_rel_insert_input -> Value
encodeUser_obj_rel_insert_input (User_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeUser_insert_input input.data |> Just ), ( "on_conflict", encodeUser_on_conflict |> Encode.optional input.on_conflict ) ]


buildUser_on_conflict : User_on_conflictRequiredFields -> User_on_conflict
buildUser_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias User_on_conflictRequiredFields =
    { constraint : Api.Enum.User_constraint.User_constraint
    , update_columns : List Api.Enum.User_update_column.User_update_column
    }


{-| Type for the User\_on\_conflict input object.
-}
type alias User_on_conflict =
    { constraint : Api.Enum.User_constraint.User_constraint
    , update_columns : List Api.Enum.User_update_column.User_update_column
    }


{-| Encode a User\_on\_conflict into a value that can be used as an argument.
-}
encodeUser_on_conflict : User_on_conflict -> Value
encodeUser_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.User_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.User_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildUser_order_by : (User_order_byOptionalFields -> User_order_byOptionalFields) -> User_order_by
buildUser_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { admin = Absent, documents_aggregate = Absent, email = Absent, firstName = Absent, id = Absent, lastName = Absent, timeStamp = Absent, username = Absent }
    in
    { admin = optionals.admin, documents_aggregate = optionals.documents_aggregate, email = optionals.email, firstName = optionals.firstName, id = optionals.id, lastName = optionals.lastName, timeStamp = optionals.timeStamp, username = optionals.username }


type alias User_order_byOptionalFields =
    { admin : OptionalArgument Api.Enum.Order_by.Order_by
    , documents_aggregate : OptionalArgument Document_aggregate_order_by
    , email : OptionalArgument Api.Enum.Order_by.Order_by
    , firstName : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , lastName : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , username : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the User\_order\_by input object.
-}
type alias User_order_by =
    { admin : OptionalArgument Api.Enum.Order_by.Order_by
    , documents_aggregate : OptionalArgument Document_aggregate_order_by
    , email : OptionalArgument Api.Enum.Order_by.Order_by
    , firstName : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , lastName : OptionalArgument Api.Enum.Order_by.Order_by
    , timeStamp : OptionalArgument Api.Enum.Order_by.Order_by
    , username : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a User\_order\_by into a value that can be used as an argument.
-}
encodeUser_order_by : User_order_by -> Value
encodeUser_order_by input =
    Encode.maybeObject
        [ ( "admin", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.admin ), ( "documents_aggregate", encodeDocument_aggregate_order_by |> Encode.optional input.documents_aggregate ), ( "email", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.email ), ( "firstName", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.firstName ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "lastName", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.lastName ), ( "timeStamp", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.timeStamp ), ( "username", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUser_set_input : (User_set_inputOptionalFields -> User_set_inputOptionalFields) -> User_set_input
buildUser_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { admin = Absent, email = Absent, firstName = Absent, id = Absent, lastName = Absent, timeStamp = Absent, username = Absent }
    in
    { admin = optionals.admin, email = optionals.email, firstName = optionals.firstName, id = optionals.id, lastName = optionals.lastName, timeStamp = optionals.timeStamp, username = optionals.username }


type alias User_set_inputOptionalFields =
    { admin : OptionalArgument Bool
    , email : OptionalArgument String
    , firstName : OptionalArgument String
    , id : OptionalArgument CustomScalarCodecs.Uuid
    , lastName : OptionalArgument String
    , timeStamp : OptionalArgument CustomScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type for the User\_set\_input input object.
-}
type alias User_set_input =
    { admin : OptionalArgument Bool
    , email : OptionalArgument String
    , firstName : OptionalArgument String
    , id : OptionalArgument CustomScalarCodecs.Uuid
    , lastName : OptionalArgument String
    , timeStamp : OptionalArgument CustomScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Encode a User\_set\_input into a value that can be used as an argument.
-}
encodeUser_set_input : User_set_input -> Value
encodeUser_set_input input =
    Encode.maybeObject
        [ ( "admin", Encode.bool |> Encode.optional input.admin ), ( "email", Encode.string |> Encode.optional input.email ), ( "firstName", Encode.string |> Encode.optional input.firstName ), ( "id", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "lastName", Encode.string |> Encode.optional input.lastName ), ( "timeStamp", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.timeStamp ), ( "username", Encode.string |> Encode.optional input.username ) ]


buildUuid_comparison_exp : (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields) -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Uuid
    , gt_ : OptionalArgument CustomScalarCodecs.Uuid
    , gte_ : OptionalArgument CustomScalarCodecs.Uuid
    , in_ : OptionalArgument (List CustomScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Uuid
    , lte_ : OptionalArgument CustomScalarCodecs.Uuid
    , neq_ : OptionalArgument CustomScalarCodecs.Uuid
    , nin_ : OptionalArgument (List CustomScalarCodecs.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Uuid
    , gt_ : OptionalArgument CustomScalarCodecs.Uuid
    , gte_ : OptionalArgument CustomScalarCodecs.Uuid
    , in_ : OptionalArgument (List CustomScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Uuid
    , lte_ : OptionalArgument CustomScalarCodecs.Uuid
    , neq_ : OptionalArgument CustomScalarCodecs.Uuid
    , nin_ : OptionalArgument (List CustomScalarCodecs.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.nin_ ) ]
