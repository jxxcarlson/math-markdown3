-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Mutation exposing
    ( DeleteDocumentRequiredArguments
    , DeleteUserRequiredArguments
    , InsertDocumentOptionalArguments
    , InsertDocumentRequiredArguments
    , InsertUserOptionalArguments
    , InsertUserRequiredArguments
    , UpdateDocumentOptionalArguments
    , UpdateDocumentRequiredArguments
    , UpdateUserOptionalArguments
    , UpdateUserRequiredArguments
    , delete_document
    , delete_user
    , insert_document
    , insert_user
    , update_document
    , update_user
    )

import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import CustomScalarCodecs
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias DeleteDocumentRequiredArguments =
    { where_ : Api.InputObject.Document_bool_exp }


{-| delete data from the table: "document"

  - where\_ - filter the rows which have to be deleted

-}
delete_document : DeleteDocumentRequiredArguments -> SelectionSet decodesTo Api.Object.Document_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_document requiredArgs object_ =
    Object.selectionForCompositeField "delete_document" [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeDocument_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeleteUserRequiredArguments =
    { where_ : Api.InputObject.User_bool_exp }


{-| delete data from the table: "user"

  - where\_ - filter the rows which have to be deleted

-}
delete_user : DeleteUserRequiredArguments -> SelectionSet decodesTo Api.Object.User_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_user requiredArgs object_ =
    Object.selectionForCompositeField "delete_user" [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeUser_bool_exp ] object_ (identity >> Decode.nullable)


type alias InsertDocumentOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.Document_on_conflict }


type alias InsertDocumentRequiredArguments =
    { objects : List Api.InputObject.Document_insert_input }


{-| insert data into the table: "document"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_document : (InsertDocumentOptionalArguments -> InsertDocumentOptionalArguments) -> InsertDocumentRequiredArguments -> SelectionSet decodesTo Api.Object.Document_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_document fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodeDocument_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_document" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Api.InputObject.encodeDocument_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias InsertUserOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.User_on_conflict }


type alias InsertUserRequiredArguments =
    { objects : List Api.InputObject.User_insert_input }


{-| insert data into the table: "user"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_user : (InsertUserOptionalArguments -> InsertUserOptionalArguments) -> InsertUserRequiredArguments -> SelectionSet decodesTo Api.Object.User_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_user fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodeUser_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_user" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Api.InputObject.encodeUser_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias UpdateDocumentOptionalArguments =
    { append_ : OptionalArgument Api.InputObject.Document_append_input
    , delete_at_path_ : OptionalArgument Api.InputObject.Document_delete_at_path_input
    , delete_elem_ : OptionalArgument Api.InputObject.Document_delete_elem_input
    , delete_key_ : OptionalArgument Api.InputObject.Document_delete_key_input
    , prepend_ : OptionalArgument Api.InputObject.Document_prepend_input
    , set_ : OptionalArgument Api.InputObject.Document_set_input
    }


type alias UpdateDocumentRequiredArguments =
    { where_ : Api.InputObject.Document_bool_exp }


{-| update data of the table: "document"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_document : (UpdateDocumentOptionalArguments -> UpdateDocumentOptionalArguments) -> UpdateDocumentRequiredArguments -> SelectionSet decodesTo Api.Object.Document_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_document fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_append" filledInOptionals.append_ Api.InputObject.encodeDocument_append_input, Argument.optional "_delete_at_path" filledInOptionals.delete_at_path_ Api.InputObject.encodeDocument_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals.delete_elem_ Api.InputObject.encodeDocument_delete_elem_input, Argument.optional "_delete_key" filledInOptionals.delete_key_ Api.InputObject.encodeDocument_delete_key_input, Argument.optional "_prepend" filledInOptionals.prepend_ Api.InputObject.encodeDocument_prepend_input, Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodeDocument_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_document" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeDocument_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdateUserOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.User_set_input }


type alias UpdateUserRequiredArguments =
    { where_ : Api.InputObject.User_bool_exp }


{-| update data of the table: "user"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_user : (UpdateUserOptionalArguments -> UpdateUserOptionalArguments) -> UpdateUserRequiredArguments -> SelectionSet decodesTo Api.Object.User_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_user fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodeUser_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_user" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeUser_bool_exp ]) object_ (identity >> Decode.nullable)
